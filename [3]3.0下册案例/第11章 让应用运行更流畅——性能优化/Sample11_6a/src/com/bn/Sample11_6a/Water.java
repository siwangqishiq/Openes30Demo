package com.bn.Sample11_6a;

import static com.bn.Sample11_6a.ShaderUtil.createProgram;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import android.opengl.GLES31;

//纹理三角形
public class Water 
{	
	int mProgram;//自定义渲染管线程序id
    int muMVPMatrixHandle;//总变换矩阵引用id
    int muMMatrixHandle;//位置、旋转变换矩阵引用
    int muLightLocationHandle;//光源位置属性引用
    int muCameraHandle; //摄像机位置属性引用 
    int mutexCoorOffsetHandle;//每帧的纹理坐标偏移引用id
    
    int maPositionHandle; //顶点位置属性引用id  
    int maNormalHandle; //顶点法向量属性引用id  
    int maTexCoorHandle; //顶点纹理坐标属性引用id  
    String mVertexShader;//顶点着色器    	 
    String mFragmentShader;//片元着色器
	
	FloatBuffer   mVertexBuffer;//顶点坐标数据缓冲
	FloatBuffer   mNormalBuffer;//顶点坐标数据缓冲
	FloatBuffer   mTexCoorBuffer;//顶点纹理坐标数据缓冲
	IntBuffer   mIndexBuffer;//组装索引缓冲
	
    int vCount=0;   
    int iCount=0;

    //各个正弦波形的起始角
    float qsj1=0;
    float qsj2=90;
    float qsj3=45;
    
    float[] bx1={50,150};
    float bc1=32;
    float zf1=0.8f;
    
    float[] bx2={10,40};
    float bc2=24;
    float zf2=1;
    
    float[] bx3={200,200};
    float bc3=60;
    float zf3=2;
    
    //每帧的纹理坐标偏移量
    float texCoorOffset=0.0f;
    
    public Water(MySurfaceView mv)
    {    	
    	//初始化顶点坐标与着色数据
    	initVertexData();
    	//初始化着色器        
    	initShader(mv);
    }
    float vertices0[];
    //更新顶点数据的方法
    public void updateVertexData()
    {
    	 //第1个波的起始角
  	     qsj1=(qsj1+9)%360;
  	     float temp1=(float)Math.toRadians(qsj1);
  	     //第2个波的起始角
   	     qsj2=(qsj2+9)%360;
   	     float temp2=(float)Math.toRadians(qsj2);
   	     //第3个波的起始角
   	     qsj3=(qsj3+4.0f)%360;
   	     float temp3=(float)Math.toRadians(qsj3);
   	     int tempCount=0;
   	     for(int j=0;j<=Constant.WATER_HEIGHT;j++)
   	     {
   	    	 for(int i=0;i<=Constant.WATER_WIDTH;i++)
   	    	 {
   	    		float[] ddxz={vertices0[tempCount*3],vertices0[tempCount*3+2]};
   	    		vertices0[tempCount*3+1]=Constant.calHdr(bx1,bc1,zf1,temp1,ddxz)+
   	    				Constant.calHdr(bx2,bc2,zf2,temp2,ddxz)+
                           Constant.calHdr(bx3,bc3,zf3,temp3,ddxz);
   	    		
   	    		normals0[tempCount*3]=0;
   	    		normals0[tempCount*3+1]=0;
   	    		normals0[tempCount*3+2]=0;
   	    		
   	    		tempCount++;
   	    	 }
   	     }
    }
    
    int indexs0[];
    float normals0[];
    //更新法向量数据
    public void updateNormalData()
    {
    	int tempCount=0;
    	for(int i=0;i<Constant.WATER_WIDTH;i++)
    	{
    		for(int j=0;j<Constant.WATER_HEIGHT;j++)
    		{
				//求0号点到1号点的向量
	      		float vxa=vertices0[indexs0[tempCount*6+1]*3]-vertices0[indexs0[tempCount*6]*3];
	      		float vya=vertices0[indexs0[tempCount*6+1]*3+1]-vertices0[indexs0[tempCount*6]*3+1];
	      		float vza=vertices0[indexs0[tempCount*6+1]*3+2]-vertices0[indexs0[tempCount*6]*3+2];
	      	    //求0号点到2号点的向量
	      		float vxb=vertices0[indexs0[tempCount*6+2]*3]-vertices0[indexs0[tempCount*6]*3];
	      		float vyb=vertices0[indexs0[tempCount*6+2]*3+1]-vertices0[indexs0[tempCount*6]*3+1];
	      		float vzb=vertices0[indexs0[tempCount*6+2]*3+2]-vertices0[indexs0[tempCount*6]*3+2];		
    			float[] nor=Constant.vectorNormal(Constant.getCrossProduct(vxa,vya,vza,vxb,vyb,vzb));
    			
    			normals0[indexs0[tempCount*6]*3]+=nor[0];
    			normals0[indexs0[tempCount*6]*3+1]+=nor[1];
    			normals0[indexs0[tempCount*6]*3+2]+=nor[2];
    			
    			normals0[indexs0[tempCount*6+1]*3]+=nor[0];
    			normals0[indexs0[tempCount*6+1]*3+1]+=nor[1];
    			normals0[indexs0[tempCount*6+1]*3+2]+=nor[2];
    			
    			normals0[indexs0[tempCount*6+2]*3]+=nor[0];
    			normals0[indexs0[tempCount*6+2]*3+1]+=nor[1];
    			normals0[indexs0[tempCount*6+2]*3+2]+=nor[2];
	      		
    			//求0号点到1号点的向量
	      		vxa=vertices0[indexs0[tempCount*6+4]*3]-vertices0[indexs0[tempCount*6+3]*3];
	      		vya=vertices0[indexs0[tempCount*6+4]*3+1]-vertices0[indexs0[tempCount*6+3]*3+1];
	      		vza=vertices0[indexs0[tempCount*6+4]*3+2]-vertices0[indexs0[tempCount*6+3]*3+2];
	      	    //求0号点到2号点的向量
	      		vxb=vertices0[indexs0[tempCount*6+5]*3]-vertices0[indexs0[tempCount*6+3]*3];
	      		vyb=vertices0[indexs0[tempCount*6+5]*3+1]-vertices0[indexs0[tempCount*6+3]*3+1];
	      		vzb=vertices0[indexs0[tempCount*6+5]*3+2]-vertices0[indexs0[tempCount*6+3]*3+2];		
    			float[] nor0=Constant.vectorNormal(Constant.getCrossProduct(vxa,vya,vza,vxb,vyb,vzb));
    			
    			normals0[indexs0[tempCount*6+3]*3]+=nor0[0];
    			normals0[indexs0[tempCount*6+3]*3+1]+=nor0[1];
    			normals0[indexs0[tempCount*6+3]*3+2]+=nor0[2];
    			
    			normals0[indexs0[tempCount*6+4]*3]+=nor0[0];
    			normals0[indexs0[tempCount*6+4]*3+1]+=nor0[1];
    			normals0[indexs0[tempCount*6+4]*3+2]+=nor0[2];
    			
    			normals0[indexs0[tempCount*6+5]*3]+=nor[0];
    			normals0[indexs0[tempCount*6+5]*3+1]+=nor[1];
    			normals0[indexs0[tempCount*6+5]*3+2]+=nor[2];
    			
	      		tempCount++;
    		}
    	}
    	
    }
   
    public void update()
    {
    	mVertexBuffer.clear();//清空顶点坐标数据缓冲
        mVertexBuffer.put(vertices0);//向缓冲区中放入顶点坐标数据
        mVertexBuffer.position(0);//设置缓冲区起始位置
        
        mNormalBuffer.clear();
        mNormalBuffer.put(normals0);//向缓冲区中放入顶点坐标数据
        mNormalBuffer.position(0);//设置缓冲区起始位置        
    }
    //初始化顶点坐标与着色数据的方法
    public void initVertexData()
    {
    	//顶点坐标数据的初始化================begin============================
    	vCount=(Constant.WATER_WIDTH+1)*(Constant.WATER_HEIGHT+1);
    	float vertices[]=new float[vCount*3];
    	int tempCount=0;
    	
    	for(int j=0;j<=Constant.WATER_HEIGHT;j++)
    	{
    		for(int i=0;i<=Constant.WATER_WIDTH;i++)
    		{
    			float x=Constant.WATER_UNIT_SIZE*i;
    			float z=Constant.WATER_UNIT_SIZE*j;
    			float y=0;
    			vertices[tempCount*3]=x;
    			vertices[tempCount*3+1]=y;
    			vertices[tempCount*3+2]=z;
    			tempCount++; 
    		}
    	} 	
    	vertices0=vertices;
        //创建顶点坐标数据缓冲
        //vertices.length*4是因为一个整数四个字节
        ByteBuffer vbb = ByteBuffer.allocateDirect(vertices.length*4);
        vbb.order(ByteOrder.nativeOrder());//设置字节顺序
        mVertexBuffer = vbb.asFloatBuffer();//转换为Float型缓冲
        mVertexBuffer.put(vertices);//向缓冲区中放入顶点坐标数据
        mVertexBuffer.position(0);//设置缓冲区起始位置
        //特别提示：由于不同平台字节顺序不同数据单元不是字节的一定要经过ByteBuffer
        //转换，关键是要通过ByteOrder设置nativeOrder()，否则有可能会出问题
        //顶点坐标数据的初始化================end============================
        
        //顶点法向量数据的初始化================begin============================
        float normals[]=new float[vCount*3];
    	tempCount=0;
    	
    	for(int j=0;j<=Constant.WATER_HEIGHT;j++)
    	{
    		for(int i=0;i<=Constant.WATER_WIDTH;i++)
    		{    			
    			normals[tempCount*3]=0;
    			normals[tempCount*3+1]=1;
    			normals[tempCount*3+2]=0;
    			tempCount++; 
    		}
    	} 	
    	normals0=normals;
        //创建顶点坐标数据缓冲
        //vertices.length*4是因为一个整数四个字节
        ByteBuffer nbb = ByteBuffer.allocateDirect(normals.length*4);
        nbb.order(ByteOrder.nativeOrder());//设置字节顺序
        mNormalBuffer = nbb.asFloatBuffer();//转换为Float型缓冲
        mNormalBuffer.put(normals);//向缓冲区中放入顶点坐标数据
        mNormalBuffer.position(0);//设置缓冲区起始位置        
        //顶点法向量数据的初始化================end============================
        
        
        //顶点纹理坐标数据的初始化================begin============================
        float texCoor[]=new float[vCount*2];
        tempCount=0;
        
        for(int j=0;j<=Constant.WATER_HEIGHT;j++)
    	{
        	for(int i=0;i<=Constant.WATER_WIDTH;i++)
    		{
    			float s=(1.0f/Constant.WATER_WIDTH)*i;
    			float t=(1.0f/Constant.WATER_HEIGHT)*j;

    			texCoor[tempCount*2]=s;
    			texCoor[tempCount*2+1]=t;
    			tempCount++;
    		}
    	}
          
        //创建顶点纹理坐标数据缓冲
        ByteBuffer cbb = ByteBuffer.allocateDirect(texCoor.length*4);
        cbb.order(ByteOrder.nativeOrder());//设置字节顺序
        mTexCoorBuffer = cbb.asFloatBuffer();//转换为Float型缓冲
        mTexCoorBuffer.put(texCoor);//向缓冲区中放入顶点着色数据
        mTexCoorBuffer.position(0);//设置缓冲区起始位置
        //特别提示：由于不同平台字节顺序不同数据单元不是字节的一定要经过ByteBuffer
        //转换，关键是要通过ByteOrder设置nativeOrder()，否则有可能会出问题
        //顶点纹理坐标数据的初始化================end============================
        
        //顶点组装索引数据的初始化================begin============================
        iCount=Constant.WATER_WIDTH*Constant.WATER_HEIGHT*6;
        int[] indexs=new int[iCount];
        tempCount=0;
        for(int i=0;i<Constant.WATER_WIDTH;i++)
    	{
    		for(int j=0;j<Constant.WATER_HEIGHT;j++)
    		{
    			//0---1
    			//| / |
    			//3---2
    			int widthTemp=Constant.WATER_WIDTH+1;
    			int index0=j*widthTemp+i;   
    			int index1=index0+1; 
    			int index2=index0+1+widthTemp;
    			int index3=index0+widthTemp;
    			
    			//0-3-1
    			indexs[tempCount*6]=index0;
    			indexs[tempCount*6+1]=index3;
    			indexs[tempCount*6+2]=index1;
    			
    			//1-3-2
				indexs[tempCount*6+3]=index1;
    			indexs[tempCount*6+4]=index3;
    			indexs[tempCount*6+5]=index2;
    			
    			tempCount++;
    		}
    	}
        indexs0=indexs;
        ByteBuffer ibb = ByteBuffer.allocateDirect(indexs.length*4);
        ibb.order(ByteOrder.nativeOrder());//设置字节顺序        
        mIndexBuffer=ibb.asIntBuffer();
        mIndexBuffer.put(indexs);
        mIndexBuffer.position(0);
    }

    //初始化着色器
    public void initShader(MySurfaceView mv)
    {
    	//加载顶点着色器的脚本内容
        mVertexShader=ShaderUtil.loadFromAssetsFile("vertex.sh", mv.getResources());
        //加载片元着色器的脚本内容
        mFragmentShader=ShaderUtil.loadFromAssetsFile("frag.sh", mv.getResources());  
        //基于顶点着色器与片元着色器创建程序
        mProgram = createProgram(mVertexShader, mFragmentShader);
        //获取程序中顶点位置属性引用id  
        maPositionHandle = GLES31.glGetAttribLocation(mProgram, "aPosition");
        //获取程序中顶点法向量属性引用id  
        maNormalHandle = GLES31.glGetAttribLocation(mProgram, "aNormal");
        //获取程序中顶点纹理坐标属性引用id  
        maTexCoorHandle= GLES31.glGetAttribLocation(mProgram, "aTexCoor");
        //获取程序中总变换矩阵引用id
        muMVPMatrixHandle = GLES31.glGetUniformLocation(mProgram, "uMVPMatrix");  
        //获取程序中位置、旋转变换矩阵引用id
        muMMatrixHandle = GLES31.glGetUniformLocation(mProgram, "uMMatrix");
        //获取程序中光源位置属性引用id
        muLightLocationHandle = GLES31.glGetUniformLocation(mProgram, "uLightLocation");
        //获取程序中摄像机位置属性引用 id
        muCameraHandle = GLES31.glGetUniformLocation(mProgram, "uCamera"); 
        //获取程序中纹理坐标偏移属性引用 id
        mutexCoorOffsetHandle = GLES31.glGetUniformLocation(mProgram, "utexCoorOffset"); 
    }
    
    public void drawSelf(int texId)
    {     
    	 updateVertexData();
    	 updateNormalData();
    	 update();
    	 //制定使用某套shader程序
    	 GLES31.glUseProgram(mProgram);        
    	 
    	 MatrixState.setInitStack();
    	 
         //设置沿Z轴正向位移1
         MatrixState.translate(0, 0, 1);

         //将最终变换矩阵传入shader程序
         GLES31.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, MatrixState.getFinalMatrix(), 0); 
         //将位置、旋转变换矩阵传入着色器程序
         GLES31.glUniformMatrix4fv(muMMatrixHandle, 1, false, MatrixState.getMMatrix(), 0);
         //将光源位置传入着色器程序   
         GLES31.glUniform3fv(muLightLocationHandle, 1, MatrixState.lightPositionFB);
         //将摄像机位置传入着色器程序   
         GLES31.glUniform3fv(muCameraHandle, 1, MatrixState.cameraFB);   
         //将纹理坐标偏移传入着色器程序
         texCoorOffset=(texCoorOffset+0.001f)%10.0f;
         GLES31.glUniform1f(mutexCoorOffsetHandle,texCoorOffset);    
         
         //将顶点坐标数据送入渲染管线
         GLES31.glVertexAttribPointer  
         (
         		maPositionHandle,   
         		3, 
         		GLES31.GL_FLOAT, 
         		false,
                3*4,   
                mVertexBuffer
         );    
         //将顶点法向量数据送入渲染管线
         GLES31.glVertexAttribPointer  
         (
        		maNormalHandle,   
         		3, 
         		GLES31.GL_FLOAT, 
         		false,
                3*4,   
                mNormalBuffer
         );             
         //将顶点纹理坐标数据送入渲染管线
         GLES31.glVertexAttribPointer  
         (
        		maTexCoorHandle, 
         		2, 
         		GLES31.GL_FLOAT, 
         		false,
                2*4,   
                mTexCoorBuffer
         );
         //允许顶点位置数据数组
         GLES31.glEnableVertexAttribArray(maPositionHandle);  
         GLES31.glEnableVertexAttribArray(maNormalHandle);  
         GLES31.glEnableVertexAttribArray(maTexCoorHandle);  
         
         //绑定纹理
         GLES31.glActiveTexture(GLES31.GL_TEXTURE0);
         GLES31.glBindTexture(GLES31.GL_TEXTURE_2D, texId);

         GLES31.glDrawElements(GLES31.GL_TRIANGLES, iCount, GLES31.GL_UNSIGNED_INT, mIndexBuffer);
    }
}
